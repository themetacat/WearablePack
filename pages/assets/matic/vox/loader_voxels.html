<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Babylon Template</title>
    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 75%;
            /* height: 70%; */
            touch-action: none;
        }

    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vox.js@1.1.0/build/vox.min.js"></script>
</head>

<body>
    <div id="gizmos" class="active" style="position: relative; height: 80%; top: 10%;">
        <canvas id="renderCanvas"></canvas>
        <div style="position: absolute; top: 10px;">
            <button id="gizmo-position">Position</button>
            <button id="gizmo-rotation">Rotation</button>
            <button id="gizmo-scale">Scale</button>
        </div>
        <div style="position: absolute; right: 10px; top: 10px;">
            <div class="editor-field position">
                <label for="position[x]">Position</label>
                <div class="fields">
    
                    <input id="position[x]" type="number" step="0.01" title="x"
                        onInput="updatePosition('position', 0, this.value)"
                        onChange="updatePosition('position', 0, this.value)">
                    <input id="position[y]" type="number" step="0.01" title="y"
                        onInput="updatePosition('position', 1, this.value)"
                        onChange="updatePosition('position', 1, this.value)">
                    <input id="position[z]" type="number" step="0.01" title="z"
                        onInput="updatePosition('position', 2, this.value)"
                        onChange="updatePosition('position', 2, this.value)">
                </div>
            </div>
            <div class="editor-field rotation">
                <label for="rotation[x]">Rotation</label>
                <div class="fields">
                    <input id="rotation[x]" type="number" step="2" title="x"
                        onInput="updatePosition('rotation', 0, this.value)"
                        onChange="updatePosition('rotation', 0, this.value)">
                    <input id="rotation[y]" type="number" step="2" title="y"
                        onInput="updatePosition('rotation', 1, this.value)"
                        onChange="updatePosition('rotation', 1, this.value)">
                    <input id="rotation[z]" type="number" step="2" title="z"
                        onInput="updatePosition('rotation', 2, this.value)"
                        onChange="updatePosition('rotation', 2, this.value)">
                </div>
            </div>
            <div class="editor-field scale-all">
                <label for="scale">Scale</label>
                <div class="fields">
                    <input id="scale[x]" type="number" step="0.01" title="all" value="0.5"
                        onInput="updatePosition('scale', 0, this.value)" onChange="updatePosition('scale', 0, this.value)">
                    <input id="scale[y]" type="number" step="0.01" title="all" value="0.5"
                        onInput="updatePosition('scale', 1, this.value)" onChange="updatePosition('scale', 0, this.value)">
                    <input id="scale[z]" type="number" step="0.01" title="all" value="0.5"
                        onInput="updatePosition('scale', 2, this.value)" onChange="updatePosition('scale', 0, this.value)">
                    <!-- <button class="toggle">...</button> -->
                </div>
            </div>
            <div>
                <button id="mesh_dispose">Remove</button>
                    <button id="download">Download</button>
            </div>
            <div id="wearable_list">

            </div>

        </div>
    </div>
    <div class="costumer-wearable-editor">
        
        <script type="module">
            import parseMagicaVoxel from 'https://cdn.jsdelivr.net/npm/parse-magica-voxel@2.1.2/+esm'
            // import * as parseMagicaVoxel from '../node_modules/parse-magica-voxel/src/index.js'
            import ndarrayFill from 'https://cdn.jsdelivr.net/npm/ndarray-fill@1.0.2/+esm'
            import aoMesher from "https://cdn.jsdelivr.net/npm/ao-mesher@0.2.10/+esm"
            import ndarray from 'https://cdn.jsdelivr.net/npm/ndarray@1.0.19/+esm'

            function get_vox_data(requestConfig, voxMesh) {
                var parser = new vox.Parser();
                // parser.parse(requestConfig.url).then(function (parsed) {
                 console.log(requestConfig.token_id);
                parser.parse( "https://wearable.vercel.app/"+requestConfig.url.hash+".vox").then(function (parsed) {
                // parser.parse("./910a5b27-374e-45cc-b68c-99baf909b8d4.vox").then(function (parsed) {
                    //     console.log(parsed);
                    // })
                    // // fetch(requestConfig.url)
                    // fetch('./a13acf48-03e1-4168-a5df-40a6d1517741.vox')
                    //     // // fetch('./910a5b27-374e-45cc-b68c-99baf909b8d4.vox')
                    //     .then(r => r.arrayBuffer())
                    //     .then(buffer => {

                    //         let parsed = parseMagicaVoxel(buffer)
                    //         console.log(parsed);
                    let size = parsed.size

                    // Oversize because ao-mesher doesn't create faces on the boundaries
                    // 5
                    size.x += 2
                    size.y += 2
                    size.z += 2

                    // Construct an ndarray
                    let field = ndarray(new Uint16Array(size.x * size.y * size.z), [size.x, size.y, size.z])
                    ndarrayFill(field, (x, y, z) => 0)

                    parsed.voxels.forEach(row => {
                        let { x, y, z, colorIndex } = row
                        field.set(x, y, z, colorIndex + (1 << 15))
                    })
console.log(parsed.voxels);
                    const vertData = aoMesher(field)

                    // Convert the vertData format into a babylon.js Mesh
                    let face = 0
                    let i = 0
                    // 大小
                    let s = 0.01

                    const hue = 0
                    const positions = []
                    const indices = []
                    const normals = []
                    const colors = []

                    // Identity function, use these to nudge the mesh as needed
                    const fx = x => x
                    const fy = y => y
                    const fz = z => z

                    while (i < vertData.length) {
                        const textureIndex = vertData[i + 7]

                        // const color = new BABYLON.Color3(1, 1, 0)
                        // var a = new BABYLON.Vector3(vertData[i + 0], vertData[i + 1], vertData[i + 2])

                        positions.push(fx(vertData[i + 0] * s))
                        positions.push(fy(vertData[i + 1] * s))
                        positions.push(fz(vertData[i + 2] * s))
                        i += 8

                        // var b = new BABYLON.Vector3(vertData[i + 0], vertData[i + 1], vertData[i + 2])
                        positions.push(fx(vertData[i + 0] * s))
                        positions.push(fy(vertData[i + 1] * s))
                        positions.push(fz(vertData[i + 2] * s))
                        i += 8

                        // var c = new BABYLON.Vector3(vertData[i + 0], vertData[i + 1], vertData[i + 2])
                        positions.push(fx(vertData[i + 0] * s))
                        positions.push(fy(vertData[i + 1] * s))
                        positions.push(fz(vertData[i + 2] * s))
                        i += 8

                        // Face index
                        indices.push(face + 0, face + 2, face + 1)

                        const intensity = 0.5
                        const offset = 0.4
                        let color = new BABYLON.Color3(parsed.palette[textureIndex].r / 255, parsed.palette[textureIndex].g / 255, parsed.palette[textureIndex].b / 255)

                        colors.push(color.r * (vertData[i - 24 + 3] / 255 * intensity + offset))
                        colors.push(color.g * (vertData[i - 24 + 3] / 255 * intensity + offset))
                        colors.push(color.b * (vertData[i - 24 + 3] / 255 * intensity + offset))
                        colors.push(1)

                        colors.push(color.r * (vertData[i - 16 + 3] / 255 * intensity + offset))
                        colors.push(color.g * (vertData[i - 16 + 3] / 255 * intensity + offset))
                        colors.push(color.b * (vertData[i - 16 + 3] / 255 * intensity + offset))
                        colors.push(1)

                        colors.push(color.r * (vertData[i - 8 + 3] / 255 * intensity + offset))
                        colors.push(color.g * (vertData[i - 8 + 3] / 255 * intensity + offset))
                        colors.push(color.b * (vertData[i - 8 + 3] / 255 * intensity + offset))
                        colors.push(1)

                        face += 3
                    }

                    requestConfig.positions = positions

                    requestConfig.indices = indices
                    requestConfig.colors = colors
                    // return requestConfig
                    let { positions: t, indices: r, colors: co, colliderPositions: ca, colliderIndices: cc } = requestConfig;
                    const vertexData = new BABYLON.VertexData();

                    vertexData.positions = t;
                    vertexData.indices = r;
                    vertexData.colors = co;

                    // BABYLON.VertexData.ComputeNormals(positions, indices, normals);
                    // vertexData.normals = normals;

                    vertexData.applyToMesh(voxMesh);
                    // voxMesh.position.y = 0.926;
                    // voxMesh.position.y = 1.509;

                    voxMesh.checkCollisions = false;
                    voxMesh.refreshBoundingInfo();
                    return voxMesh
                })

            }
            window.get_vox_data = get_vox_data;
        </script>
        <script>

            // import babylonjsmaterials from 'https://cdn.jsdelivr.net/npm/@babylonjs/materials@6.17.0/+esm'
            // import babylonjsloaders from 'https://cdn.jsdelivr.net/npm/@babylonjs/loaders@6.17.0/+esm'
            // import babylonjs from 'https://cdn.jsdelivr.net/npm/babylonjs@6.17.0/+esm'
            // import parseMagicaVoxel from 'https://cdn.jsdelivr.net/npm/parse-magica-voxel@2.1.2/+esm'
            // import ndarrayFill from 'https://cdn.jsdelivr.net/npm/ndarray-fill@1.0.2/+esm'
            // import aoMesher from "https://cdn.jsdelivr.net/npm/ao-mesher@0.2.10/+esm"
            // import ndarray from 'https://cdn.jsdelivr.net/npm/ndarray@1.0.19/+esm'
            const canvas = document.getElementById("renderCanvas");
            const engine = new BABYLON.Engine(canvas, true);

            var voxMesh = null;
            var targetBone = null
            var attachmentId = null;
            const chain_info = {
                1: "eth",
                137: "polygon",
                80007: "mumbai",
                0: "off-chain"
            };

            var costume = {
                "id": 79413,
                "wallet": "0x60ea96f57b3a5715a90dae1440a78f8bb339c92e",
                "attachments": [],
                "skin": null,
                "name": "Costume-2",
                "default_color": "#f3f3f3"
            }

            const onClick = e => {
                if (!e) {
                    if (layer())
                        layer().removeAllMeshes();
                    if (gizmoManager) {
                        gizmoManager.attachToMesh(null)
                    }
                    update_voxMesh(null)
                }
            };

            const createScene = function () {
                const scene = new BABYLON.Scene(engine);

                // Set the scene's clear color
                scene.clearColor = new BABYLON.Color4(1, 1, 1, 1);

                if (onClick) {
                    const lastPointerPosition = new BABYLON.Vector2();
                    let isDragging = false;

                    scene.onPointerObservable.add(eventData => {
                        switch (eventData.type) {
                            case BABYLON.PointerEventTypes.POINTERDOWN:
                                isDragging = false;
                                lastPointerPosition.set(eventData.event.clientX, eventData.event.clientY);
                                break;
                            case BABYLON.PointerEventTypes.POINTERUP:
                                if (isDragging || eventData.event.button !== 0) return;
                                onClick(eventData.pickInfo?.hit && eventData.pickInfo.pickedMesh);
                                if (eventData.pickInfo.pickedMesh) {
                                    if (voxMesh != eventData.pickInfo.pickedMesh) {
                                        // voxMesh = eventData.pickInfo.pickedMesh
                                        update_voxMesh(eventData.pickInfo.pickedMesh)
                                        focus()
                                    }
                                }
                                break;
                            case BABYLON.PointerEventTypes.POINTERMOVE:
                                if (isDragging) break;
                                const distance = lastPointerPosition.subtract(new BABYLON.Vector2(eventData.event.clientX, eventData.event.clientY)).length();
                                if (distance > 8) isDragging = true;
                                break;
                        }
                    }, BABYLON.PointerEventTypes.POINTERDOWN + BABYLON.PointerEventTypes.POINTERUP + BABYLON.PointerEventTypes.POINTERMOVE);
                }

                // 创建 ArcRotateCamera 相机
                const camera = new BABYLON.ArcRotateCamera("Camera", -1.57, 1.4, 2.4, new BABYLON.Vector3(0, 0.9, 0), scene);
                camera.attachControl(canvas, true);
                camera.lowerRadiusLimit = 0.5;
                camera.upperRadiusLimit = 8;
                camera.wheelPrecision = 30;
                camera.panningInertia = 0;
                camera.panningSensibility = 350;
                camera.inertialRadiusOffset = 0;
                camera.minZ = 0.003;

                // 创建 Cylinder 形状的天空盒
                const skybox = BABYLON.MeshBuilder.CreateCylinder("skybox", {
                    height: 64,
                    diameterTop: 64,
                    diameterBottom: 64,
                    tessellation: 64,
                    subdivisions: 64
                }, scene);
                skybox.isPickable = false;

                const skyMaterial = new BABYLON.GradientMaterial("skybox/horizon", scene);
                skyMaterial.offset = 0;
                skyMaterial.scale = -0.01;
                skyMaterial.topColor.set(0.7, 0.7, 0.7);
                skyMaterial.bottomColor.set(1, 1, 1);
                skyMaterial.backFaceCulling = false;
                skyMaterial.disableLighting = true;
                skyMaterial.blockDirtyMechanism = true;
                skybox.material = skyMaterial;

                createLightRing(scene, camera)

                // 设置高亮层
                const highlightLayer = new BABYLON.HighlightLayer("selected", scene, {
                    isStroke: true
                });
                highlightLayer.innerGlow = false;
                highlightLayer.outerGlow = true;
                const glowSize = 0.2;
                highlightLayer.blurHorizontalSize = glowSize;
                highlightLayer.blurVerticalSize = glowSize;

                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

                // Default intensity is 1. Let's dim the light a small amount
                light.intensity = 0.7;

                const costumeMaterial = new BABYLON.StandardMaterial(`material/costume`, scene);
                costumeMaterial.diffuseColor.set(0.82, 0.81, 0.8);
                costumeMaterial.emissiveColor.set(0.1, 0.1, 0.1);
                costumeMaterial.specularPower = 1000;
                costumeMaterial.blockDirtyMechanism = true;
                material = costumeMaterial;
                BABYLON.SceneLoader.ImportMesh(null, `./`, "avatar.glb", scene, (meshes, particleSystems, skeletons) => {
                    let costumeMesh, bodyMesh, skeletonRoot;

                    costumeMesh = meshes[0];
                    const costumeId = 1;
                    costumeMesh.id = `costume/${costumeId}`;
                    costumeMesh.visibility = 0;
                    costumeMesh.isPickable = false;

                    bodyMesh = meshes[1];
                    bodyMesh.material = costumeMaterial;
                    bodyMesh.isPickable = false;
                    // this.applySkin();
                    skeletonRoot = skeletons[0];
                    window["skeleton"] = skeletonRoot;
                    const bones = skeletonRoot.bones.filter((bone) => !bone.name.match(/index/i));
                    const firstBone = bones[0];
                    const boneTransformNode = firstBone.getTransformNode();

                    if (boneTransformNode !== null) {
                        boneTransformNode.rotate(BABYLON.Axis.Y, Math.PI);
                    }

                    const boneMeshes = [];
                    bones.forEach((bone) => {
                        const boneSphere = BABYLON.MeshBuilder.CreateSphere("bonesphere", {
                            diameter: 0.1
                        }, scene);
                        boneMeshes.push(boneSphere);
                        boneSphere.id = "bonesphere";
                        boneSphere.attachToBone(bone, bodyMesh);
                        boneSphere.metadata = bone.name.replace(/^.+:/, "");
                        const boneMaterial = new BABYLON.StandardMaterial("target", scene);
                        boneMaterial.emissiveColor.set(1, 1, 1);
                        boneMaterial.disableLighting = true;
                        boneMaterial.alpha = 0.5;
                        boneMaterial.blockDirtyMechanism = true;
                        boneSphere.material = boneMaterial;
                        boneSphere.renderingGroupId = 2;
                        boneSphere.setEnabled(false);
                    });
                })

                return scene;
            };
            const scene = createScene();
            // 坐标向量
            const gizmoManager = get_GizmoManager()

            function createLightRing(scene, camera) {
                const ringTransformNode = new BABYLON.TransformNode("ring", scene);
                ringTransformNode.setParent(camera);
                ringTransformNode.position.z = -5;

                const redLight = new BABYLON.PointLight("redLight", new BABYLON.Vector3(0, 10, 0), scene);
                redLight.diffuse.set(0.1, 0.1, 0.01);
                redLight.specular.set = (1, 0.7647058823529411, 0.5411764705882353)
                redLight.parent = ringTransformNode;

                const greenLight = new BABYLON.PointLight("greenLight", new BABYLON.Vector3(1, -5, 0), scene);
                greenLight.diffuse.set = (0.2784313725490196, 0.6352941176470588, 1);
                greenLight.specular.set(0, 0, 0);
                greenLight.intensity = 0.2;
                greenLight.parent = ringTransformNode;

                const blueLight = new BABYLON.PointLight("blueLight", new BABYLON.Vector3(-8.66, -1, 2), scene);
                blueLight.diffuse.set = { b: 0.4235294117647059, g: 0.7058823529411765, r: 1 };
                blueLight.specular.set(0, 0, 0);
                blueLight.intensity = 0.2;
                blueLight.parent = ringTransformNode;

                const rotationAnimation = new BABYLON.Animation("lightRing", "rotation.z", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                const rotationKeys = [
                    { frame: 0, value: 0 },
                    { frame: 300, value: 2 * Math.PI }
                ];
                rotationAnimation.setKeys(rotationKeys);
                ringTransformNode.animations = [rotationAnimation];
                scene.beginAnimation(ringTransformNode, 0, 300, true);
            }

            function getWearableURL(droppedWearable) {
                return `/c/v2/${chain_info[droppedWearable.chain_id]}/${droppedWearable.collection_address}/${droppedWearable.token_id}/vox`
            }

            // 模型高亮层
            function layer() {
                var e, t;
                return (t = (e = scene) === null || e === void 0 ? void 0 : e.getHighlightLayerByName("selected")) !== null && t !== void 0 ? t : null
            }

            const get_avatar = function () {
                if (!scene)
                    return null;
                return scene.getMeshByName("avatar")
            }
            // get bones info
            const bonespheres = function () {
                var e, t;
                return (t = (e = scene) === null || e === void 0 ? void 0 : e.getMeshesById("bonesphere")) !== null && t !== void 0 ? t : null
            }

            // hide bones
            const hideBoneSpheres = function () {
                console.log(bonespheres())
                var e;
                (e = bonespheres()) === null || e === void 0 ? void 0 : e.forEach((e => {
                    e.setEnabled(false)
                }
                ))
            }

            function onDrop() {
                hideBoneSpheres(); // 隐藏骨骼球体
                // 异步添加可穿戴物品到装饰中
                if (!targetBone) {
                    console.log('no Bone');
                    return
                }
                // 获取被拖放的可穿戴物品
                const droppedWearable = getDroppedWearable();
                if (!droppedWearable) {
                    console.warn("no wearable"); // 没有可穿戴物品，打印警告信息
                    return;
                }

                // // 判断是否能够将可穿戴物品添加到装饰中
                // if (!canAdd(droppedWearable)) {
                //     showSnackbar("Unable to add to costume", "Warning"); // 显示消息提示，无法添加到装饰中
                //     return;
                // }

                addAttachment(droppedWearable, targetBone)
                    .then(() => {
                        console.log('apply addAttachment');
                    })
                    .catch((error) => {
                        console.error("Error adding attachment:", error);
                    });
                const r = {
                    invertX: false
                }
                renderVoxModel(droppedWearable, scene, r, targetBone)

            }

            async function addAttachment(wearable, bone) {
                // if (!selectedCostume) {
                //     showSnackbar("Can't attach wearable when no costume is selected", MessageType.Warning, 5000);
                //     return;
                // }

                const defaultScale = 0.5;
                const updatedCostume = Object.assign({}, costume);
                const uniqueId = generateUUID();

                const attachmentInfo = {
                    name: wearable.name,
                    wearable_id: typeof wearable.token_id === "number" ? wearable.token_id : parseInt(wearable.token_id, 10),
                    collection_address: wearable.collection_address || undefined,
                    chain_id: wearable.chain_id,
                    collection_id: typeof wearable.collection_id === "number" ? wearable.collection_id : parseInt(wearable.collection_id, 10),
                    position: [0, 0, 0],
                    rotation: [0, 0, 0],
                    scaling: [defaultScale, defaultScale, defaultScale],
                    bone: bone,
                    uuid: uniqueId,
                };

                if (!updatedCostume.attachments) {
                    updatedCostume.attachments = [];
                }
                updatedCostume.attachments.push(attachmentInfo);
                attachmentId = uniqueId

                // const expandAttachments = true;

                // 调用api 更新Costume数据
                // await updateCostume(updatedCostume);
            }

            function bone(e) {
                if (!skeleton)
                    return null;
                const t = skeleton.getBoneIndexByName(`mixamorig:${e}`);
                if (t == -1) {
                    console.error(`Bad bone name "${e}"`);
                    return null
                }
                return this.skeleton.bones[t]
            }

            function createVoxShaderMaterial(config, lightDirection) {
                shaderMaterial = new BABYLON.ShaderMaterial("vox-model/vox-shader", config, {
                    vertex: "LegacyVox",
                    fragment: "LegacyVox"
                }, {
                    attributes: ["position", "color"],
                    uniforms: ["world", "worldViewProjection", "view", "projection", "brightness", "cameraPosition"],
                    defines: ["#define IMAGEPROCESSINGPOSTPROCESS"]
                });

                shaderMaterial.setFloat("brightness", 1);
                shaderMaterial.setVector3("vLight", lightDirection || new BABYLON.Vector3(.577, .577, -.577).normalize());
                shaderMaterial.setVector4("vFogInfos", new BABYLON.Vector4(config.fogMode, config.fogStart, config.fogEnd, config.fogDensity));
                shaderMaterial.setColor3("vFogColor", config.fogColor);
                shaderMaterial.blockDirtyMechanism = true;
            }

            function renderVoxModel(modelUrl, the_sence, options, bone_name) {
                const vertexShaderCode = 'x'; // Replace 'x' with the actual vertex shader code
                const pixelShaderCode = 'z';  // Replace 'z' with the actual pixel shader code

                BABYLON.Effect.ShadersStore["LegacyVoxVertexShader"] = vertexShaderCode;
                BABYLON.Effect.ShadersStore["LegacyVoxPixelShader"] = pixelShaderCode;

                // const workerURL = new URL(r.p + r.u(181), r.b);
                let currentRenderJobId = 0;
                let isWorkerListening = false;
                // let shaderMaterial = null;

                // if (!shaderMaterial) {
                //     createVoxShaderMaterial(the_sence);
                // }
                const shaderMaterial = new BABYLON.StandardMaterial("wearable", the_sence);
                shaderMaterial.emissiveColor.set(.3, .3, .3);
                shaderMaterial.diffuseColor.set(1, 1, 1);
                shaderMaterial.blockDirtyMechanism = true;

                const sizeHint = options && "sizeHint" in options ? options.sizeHint : [1, 1, 1];
                wearable_url = getWearableURL(droppedWearable)

                const requestConfig = {
                    renderJob: 1,
                    url: modelUrl,
                    token_id: droppedWearable.token_id,
                    flipX: options && "invertX" in options ? !!options.invertX : true,
                    megavox: options && !!options.megavox,
                    sizeHint: sizeHint
                };

                voxMesh = new BABYLON.Mesh("utils/vox-box", the_sence);
                voxMesh.material = shaderMaterial;
                voxMesh.isPickable = true;
                voxMesh.checkCollisions = false;
                // voxMesh.rotationQuaternion = BABYLON.Quaternion.Identity();

                // voxMesh.position.set(0, 0, 0);
                voxMesh.scaling.set(0.5, 0.5, 0.5);
                const origin = new BABYLON.TransformNode("Node/wearable", scene);

                voxMesh.setParent(origin);
                origin.rotation.x = -Math.PI / 2;


                const the_bone = bone(bone_name);
                if (!the_bone) {
                    console.log('no Bone');
                    return
                }
                if (get_avatar()) {
                    origin.attachToBone(the_bone, get_avatar());
                    updateAllPositionValue()
                    focus()
                    // "https://www.voxels.com/c/v2/polygon/0x1e3D804415dCbb7ceA3478f176e123562e09b514/155/vox"
                    // 将模型绕 y 轴旋转 180 度，使其正上方朝向 y 轴

                    // get vox data
                    window.get_vox_data(requestConfig, voxMesh)
                }

                voxMesh.actionManager = new BABYLON.ActionManager(scene);
                // the_wearable = getDroppedWearable()
                // voxMesh.rotation.fromArray(the_wearable.rotation.map((the_wearable=>the_wearable * Math.PI / 180)))

                // ！！！！！！
                voxMesh.id = attachmentId

                // if (this.props.onSelect)
                //     this.mesh.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickUpTrigger,this.props.onSelect));

            }

            // 获取 拖放的wearable
            function getDroppedWearable() {
                var droppedWearableValue = window["droppedWearable"];
                return droppedWearableValue !== null && droppedWearableValue !== undefined ? droppedWearableValue : null;
            }
            
            function getWearableGIFUrl(id, name) {

              const res = name === null || name === void 0 ? void 0 : name.toLowerCase().replace(/[^a-z]+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
              return "https://wearables.crvox.com/" + id + "-" + res + ".gif"
          }

            function onWheel(e) {
                e.preventDefault()
            }

            function onDragExit() {
                hideBoneSpheres()
            }

            function onDragOver(e) {
                var t;

                // 初始化目标骨骼为空
                // targetBone = null;

                // 遍历所有的 bonespheres（骨骼球体）
                const all_bonespheres = bonespheres()
                if (all_bonespheres) {
                    for (var i = 0; i < all_bonespheres.length; i++) {
                        var bonesphere = all_bonespheres[i];
                        // 启用每个 bonesphere
                        bonesphere.setEnabled(true);

                        if (!bonesphere.material) {
                            // 如果没有材质，则发出警告并返回
                            console.warn("no material", bonesphere);
                            continue;
                        }

                        var bonesphereMaterial = bonesphere.material;
                        // 将每个 bonesphere 的材质发光颜色设置为白色
                        bonesphereMaterial.emissiveColor.set(1, 1, 1);
                    }
                }

                if (scene) {
                    // 使用场景的 pick 方法，检测是否拾取到 id 为 "bonesphere" 的物体
                    var pickResult = scene.pick(e.offsetX, e.offsetY, function (mesh) {
                        return mesh.id === "bonesphere";
                    });

                    if (pickResult && pickResult.pickedMesh && pickResult.pickedMesh.material) {
                        var pickedMaterial = pickResult.pickedMesh.material;
                        // 将拾取到的物体的材质发光颜色设置为指定颜色
                        pickedMaterial.emissiveColor.set(0.3, 0, 1);
                        // 设置目标骨骼为拾取到的物体的元数据
                        targetBone = pickResult.pickedMesh.metadata;
                    } else {
                        targetBone = null
                    }

                }

                // 阻止浏览器默认行为
                e.preventDefault();
                if (e.dataTransfer) {
                    // 设置拖拽的效果为复制
                    e.dataTransfer.dropEffect = "copy";
                }
            }

            // 生成wearables列表
            function renderWearables() {
                const collectibles = [
                    {
                        "id": "4f8a99d2-89c2-4c18-ab87-b35d064021a4",
                        "token_id": 37,
                        "name": "CV Wearables: head - by MetaCat",
                        "description": "",
                        "collection_id": 353,
                        "category": "facewear",
                        "author": "0x38bbd375d49d6237984cbfa19719c419af9fe514",
                        "hash": "28614b00f9f807b8d71421d62d1612cab7501d20",
                        "suppressed": false,
                        "chain_id": 137,
                        "collection_address": "0x1e3D804415dCbb7ceA3478f176e123562e09b514",
                        "collection_name": "MetaCat"
                    },
                    {
                        "id": "e1c82d5b-ffca-49fe-864e-b5dce843d120",
                        "token_id": 41,
                        "name": "CV Wearables: Knight Hat(red) - by MetaCat",
                        "description": "",
                        "collection_id": 353,
                        "category": "facewear",
                        "author": "0x38bbd375d49d6237984cbfa19719c419af9fe514",
                        "hash": "a35eeb4b70b976fbdf09f8d87302f10ea8dd4f5f",
                        "suppressed": false,
                        "chain_id": 137,
                        "collection_address": "0x1e3D804415dCbb7ceA3478f176e123562e09b514",
                        "collection_name": "MetaCat"
                    },
                    {
                        "id": "910a5b27-374e-45cc-b68c-99baf909b8d4",
                        "token_id": 48,
                        "name": "CV Wearables: Chinese Traditional Cloak(black) - by MetaCat",
                        "description": "",
                        "collection_id": 353,
                        "category": "facewear",
                        "author": "0x38bbd375d49d6237984cbfa19719c419af9fe514",
                        "hash": "be258d360416db3ac56288f9af4d890bab4aa643",
                        "suppressed": false,
                        "chain_id": 137,
                        "collection_address": "0x1e3D804415dCbb7ceA3478f176e123562e09b514",
                        "collection_name": "MetaCat"
                    }
                ]
                const wearables = collectibles.map(wearable => {
                    const onDragStart = event => {
                        const dataTransfer = event.dataTransfer;
                        if (dataTransfer) {
                            dataTransfer.setData("text/plain", "boop");
                        }
                        event.stopImmediatePropagation();
                        if (event.target instanceof HTMLElement) {
                            event.target.className = "dragging-wearable";
                        }
                        window.droppedWearable = wearable;
                    };

                    const onDragEnd = event => {
                        if (event.target instanceof HTMLElement) {
                            event.target.className = "draggable-wearable";
                        }
                    };

                    let tooltip = `wearable #${wearable.id}`;
                    if (wearable.name) {
                        tooltip = wearable.name;
                        if (wearable.description) {
                            tooltip += `\n\n${wearable.description}`;
                        }
                    }

                    const li = document.createElement("li");
                    li.className = "draggable-wearable";
                    li.draggable = true;
                    li.title = tooltip;
                    li.addEventListener("dragstart", onDragStart);
                    li.addEventListener("dragend", onDragEnd);

                    const img = document.createElement("img");
                    img.width = 94;
                    img.height = 94;
                    // img.src = Jf(wearable);
                    img.src = getWearableGIFUrl(wearable.id, wearable.name)
                    // img.src = 'https://wearables.crvox.com/910a5b27-374e-45cc-b68c-99baf909b8d4-cv-wearables-chinese-traditional-cloak-black-by-metacat.gif'
                    img.alt = tooltip;

                    const div = document.createElement("div");
                    div.textContent = wearable.chain_id === 0 ? "(Off-chain)" : wearable.name;
                    li.appendChild(img);
                    li.appendChild(div);
                    return li;
                });

                // const fragment = document.createDocumentFragment();
                // const h3 = document.createElement("h3");
                // h3.textContent = `Wearables Wearables Wearables`;
                const div = document.getElementById("wearable_list");
                // div.className = "column-header";
                const ul = document.createElement("ul");
                ul.className = "wearables-list";
                wearables.forEach(li => ul.appendChild(li));
                // fragment.appendChild(h3);
                // div.appendChild(div);
                div.appendChild(ul);

                // document.body.appendChild(fragment);
            }
            renderWearables()

            function get_GizmoManager() {
                const gizmoManager = new BABYLON.GizmoManager(scene, 3.5);
                gizmoManager.positionGizmoEnabled = true;
                gizmoManager.rotationGizmoEnabled = true;
                gizmoManager.scaleGizmoEnabled = false;

                gizmoManager.usePointerToAttachGizmos = false;
                gizmoManager.boundingBoxGizmoEnabled = true;
                if (!gizmoManager.gizmos.positionGizmo || !gizmoManager.gizmos.rotationGizmo)
                    throw new Error("gizmos not found");
                gizmoManager.gizmos.positionGizmo.xGizmo.dragBehavior.onDragEndObservable.add(() => updateAllPositionValue());
                gizmoManager.gizmos.positionGizmo.yGizmo.dragBehavior.onDragEndObservable.add(() => updateAllPositionValue());
                gizmoManager.gizmos.positionGizmo.zGizmo.dragBehavior.onDragEndObservable.add(() => updateAllPositionValue());

                gizmoManager.gizmos.rotationGizmo.xGizmo.dragBehavior.onDragEndObservable.add(() => updateAllPositionValue());
                gizmoManager.gizmos.rotationGizmo.yGizmo.dragBehavior.onDragEndObservable.add(() => updateAllPositionValue());
                gizmoManager.gizmos.rotationGizmo.zGizmo.dragBehavior.onDragEndObservable.add(() => updateAllPositionValue());

                gizmoManager.gizmos.rotationGizmo.updateGizmoRotationToMatchAttachedMesh = false;

                if (gizmoManager.gizmos.boundingBoxGizmo) {
                    gizmoManager.gizmos.boundingBoxGizmo.scaleRatio = .8;
                    gizmoManager.gizmos.boundingBoxGizmo.scaleBoxSize = .03;
                    gizmoManager.gizmos.boundingBoxGizmo.rotationSphereSize = 0;
                    gizmoManager.gizmos.boundingBoxGizmo.onScaleBoxDragEndObservable.add(() => updateAllPositionValue())
                }

                const position = document.getElementById("gizmo-position");
                if (!position)
                    throw new Error("positionGizmo not found");
                position.addEventListener("click", (() => {
                    gizmoManager.positionGizmoEnabled = true;
                    gizmoManager.rotationGizmoEnabled = false;
                    gizmoManager.boundingBoxGizmoEnabled = false
                }
                ));
                const rotation = document.getElementById("gizmo-rotation");
                if (!rotation)
                    throw new Error("rotationGizmo not found");
                rotation.addEventListener("click", (() => {
                    gizmoManager.positionGizmoEnabled = false;
                    gizmoManager.rotationGizmoEnabled = true;
                    gizmoManager.boundingBoxGizmoEnabled = false
                }
                ));
                const scale = document.getElementById("gizmo-scale");
                if (!scale)
                    throw new Error("scaleGizmo not found");
                scale.addEventListener("click", (() => {
                    gizmoManager.positionGizmoEnabled = false;
                    gizmoManager.rotationGizmoEnabled = false;
                    gizmoManager.boundingBoxGizmoEnabled = true
                }
                ));
                gizmoManager.positionGizmoEnabled = true;
                gizmoManager.rotationGizmoEnabled = false;
                gizmoManager.boundingBoxGizmoEnabled = false;

                return gizmoManager
            }

            function focus() {
                lay = layer()
                const col = new BABYLON.Color3(.7, .3, 1);
                if (lay && voxMesh) {
                    lay.removeAllMeshes();
                    lay.addMesh(voxMesh, col)
                }
                if (gizmoManager && voxMesh)
                    gizmoManager.attachToMesh(voxMesh)
            }

            function dispose_mesh() {
                if (voxMesh) {
                    voxMesh.dispose(); // 销毁模型及其资源
                    deleteAttachment()
                    update_voxMesh(null)
                    updateAllPositionValue()
                }
            }

            function num(value) {
                const t = parseFloat(value);
                return t.toString() === value.toString() ? t : null
            }

            function update_voxMesh(value) {
                voxMesh = value
                if (voxMesh) {
                    attachmentId = voxMesh.id
                } else {
                    attachmentId = null
                }
                updateAllPositionValue(1)
            }

            function updatePosition(type, index, value) {
                if (!voxMesh) {
                    console.log('voxMesh is Null');
                    return
                }
                if (type === 'position') {
                    switch (index) {
                        case 0:
                            voxMesh.position.x = num(value)
                            break
                        case 1:
                            voxMesh.position.y = num(value)
                            break
                        case 2:
                            voxMesh.position.z = num(value)
                            break
                    }
                } else if (type === 'rotation') {
                    switch (index) {
                        case 0:
                            voxMesh.rotation.x = num(value)
                            break
                        case 1:
                            voxMesh.rotation.y = num(value)
                            break
                        case 2:
                            voxMesh.rotation.z = num(value)
                            break
                    }
                } else if (type === 'scale') {
                    switch (index) {
                        case 0:
                            voxMesh.scaling.x = num(value)
                            break
                        case 1:
                            voxMesh.scaling.y = num(value)
                            break
                        case 2:
                            voxMesh.scaling.z = num(value)
                            break
                    }
                }
                updateAttachment()
            }

            // pass
            function updateInputPositionValue(type, dir) {
                if (!voxMesh) {
                    return
                }
                if (type === 'position') {
                    switch (dir) {
                        case 0:
                            const position_x = document.getElementById("position[x]");
                            position_x.value = voxMesh.position.x.toFixed(2);
                            break
                        case 1:
                            const position_y = document.getElementById("position[y]");
                            position_y.value = voxMesh.position.y.toFixed(2);
                            break
                        case 2:
                            const position_z = document.getElementById("position[z]");
                            position_z.value = voxMesh.position.z.toFixed(2);
                            break
                    }
                } else if (type === 'rotation') {
                    switch (dir) {
                        case 0:
                            const rotation_x = document.getElementById("rotation[x]");
                            rotation_x.value = voxMesh.rotation.x.toFixed(2);
                            break
                        case 1:
                            const rotation_y = document.getElementById("rotation[y]");
                            rotation_y.value = voxMesh.rotation.y.toFixed(2);
                            break
                        case 2:
                            const rotation_z = document.getElementById("rotation[z]");
                            rotation_z.value = voxMesh.rotation.z.toFixed(2);
                            break
                    }
                } else if (type === 'scale') {
                    switch (dir) {
                        case 0:
                            const scale_x = document.getElementById("scale[x]");
                            scale_x.value = voxMesh.scaling.x.toFixed(2);
                            break
                        case 1:
                            const scale_y = document.getElementById("scale[y]");
                            scale_y.value = voxMesh.scaling.y.toFixed(2);
                            break
                        case 2:
                            const scale_z = document.getElementById("scale[z]");
                            scale.value = voxMesh.scaling.z.toFixed(2);
                            break
                    }

                }

            }

            function updateAllPositionValue(type) {

                const position_x = document.getElementById("position[x]");
                const position_y = document.getElementById("position[y]");
                const position_z = document.getElementById("position[z]");

                const rotation_x = document.getElementById("rotation[x]");
                const rotation_y = document.getElementById("rotation[y]");
                const rotation_z = document.getElementById("rotation[z]");

                const scale_x = document.getElementById("scale[x]");
                const scale_y = document.getElementById("scale[y]");
                const scale_z = document.getElementById("scale[z]");

                if (!voxMesh) {
                    position_x.value = 0.00;
                    position_y.value = 0.00;
                    position_z.value = 0.00;

                    rotation_x.value = 0.00;
                    rotation_y.value = 0.00;
                    rotation_z.value = 0.00;

                    scale_x.value = 0.5;
                    scale_y.value = 0.5;
                    scale_z.value = 0.5;
                } else {
                    // const rot = e=>Math.round(e * 1e3 * 180 / Math.PI) / 1e3;
                    // const po_sc = e=>Math.round(e * 1e3) / 1e3;

                    // [position_x.value, position_y.value, position_z.value] = voxMesh.position.asArray().map(po_sc);
                    // [rotation_x.value, rotation_y.value, rotation_z.value] = voxMesh.position.asArray().map(po_sc);
                    // [scale_x.value, scale_y.value, scale_z.value] = voxMesh.position.asArray().map(po_sc);
                    position_x.value = voxMesh.position.x.toFixed(2);
                    position_y.value = voxMesh.position.y.toFixed(2);
                    position_z.value = voxMesh.position.z.toFixed(2);

                    rotation_x.value = voxMesh.rotation.x.toFixed(2);
                    rotation_y.value = voxMesh.rotation.y.toFixed(2);
                    rotation_z.value = voxMesh.rotation.z.toFixed(2);

                    scale_x.value = voxMesh.scaling.x.toFixed(2);
                    scale_y.value = voxMesh.scaling.y.toFixed(2);
                    scale_z.value = voxMesh.scaling.z.toFixed(2);
                    if (!type) {
                        // 更新接口数据坐标
                        updateAttachment()
                    }
                }
            }

            function deleteAttachment() {
                if (!voxMesh) {
                    console.log('no voxMesh');
                    return
                }

                if (costume.attachments)
                    var index = 0;
                costume.attachments.forEach((t => {
                    if (t.uuid == attachmentId) {
                        costume.attachments.splice(index, 1);
                        return
                    }
                    index += 1
                }
                ));
            }

            function updateAttachment() {
                if (!voxMesh) {
                    console.log('no voxMesh');
                    return
                }
                if (costume.attachments)
                    costume.attachments.forEach((t => {
                        if (t.uuid == attachmentId) {
                            t.position = [voxMesh.position.x.toFixed(2), voxMesh.position.y.toFixed(2), voxMesh.position.z.toFixed(2)]
                            t.rotation = [voxMesh.rotation.x.toFixed(2), voxMesh.rotation.y.toFixed(2), voxMesh.rotation.z.toFixed(2)]
                            t.scaling = [voxMesh.scaling.x.toFixed(2), voxMesh.scaling.x.toFixed(2), voxMesh.scaling.x.toFixed(2)]
                            return true
                        }
                    }
                    ));
            }

            function downloadCostume() {
                var file_name;
                // const t = this.costume;
                if (!costume)
                    return;
                const json_costume = JSON.stringify(costume, null, 2);
                const element_dow = document.createElement("a");
                element_dow.style.display = "hidden";
                element_dow.href = window.URL.createObjectURL(new Blob([json_costume], {
                    type: "application/json"
                }));
                element_dow.download = ((file_name = costume.name) !== null && file_name !== void 0 ? file_name : costume.id) + ".json";
                element_dow.click();
                element_dow.remove()
            }

            function generateUUID(e, random, r) {
                let lastNsecs = 0
                let lastTimestamp = 0;
                let lastClockSequence = null;
                let nodeIdentifier = null;

                let index = (random && r) || 0;
                const uuidArray = random || new Array(16);
                e = e || {};

                let node = e.node || nodeIdentifier;
                let clockSeq = e.clockSeq !== undefined ? e.clockSeq : lastClockSequence;

                if (node === null || clockSeq === null) {
                    const random = getRandomValues();
                    if (node === null) {
                        node = nodeIdentifier = [random[0] | 1, random[1], random[2], random[3], random[4], random[5]];
                    }
                    if (clockSeq === null) {
                        clockSeq = lastClockSequence = (random[6] << 8 | random[7]) & 16383;
                    }
                }

                let timestamp = e.timestamp !== undefined ? e.timestamp : Date.now();
                let nsecs = e.nsecs !== undefined ? e.nsecs : lastNsecs + 1;

                const clockOffset = (timestamp - lastTimestamp + (nsecs - lastNsecs)) / 10000;

                if (clockOffset < 0 && e.clockSeq === undefined) {
                    clockSeq = (clockSeq + 1) & 16383;
                }

                if ((clockOffset < 0 || timestamp > lastTimestamp) && e.nsecs === undefined) {
                    nsecs = 0;
                }

                if (nsecs >= 10000) {
                    throw new Error("generateUUID(): Can't create more than 10M uuids/sec");
                }

                lastTimestamp = timestamp;
                lastNsecs = nsecs;
                lastClockSequence = clockSeq;

                timestamp += 122192928e5;
                const timeLow = ((timestamp & 268435455) * 10000 + nsecs) % 4294967296;
                uuidArray[index++] = timeLow >>> 24 & 255;
                uuidArray[index++] = timeLow >>> 16 & 255;
                uuidArray[index++] = timeLow >>> 8 & 255;
                uuidArray[index++] = timeLow & 255;

                const timeMid = timestamp / 4294967296 * 10000 & 268435455;
                uuidArray[index++] = timeMid >>> 8 & 255;
                uuidArray[index++] = timeMid & 255;
                uuidArray[index++] = timeMid >>> 24 & 15 | 16;
                uuidArray[index++] = timeMid >>> 16 & 255;

                uuidArray[index++] = clockSeq >>> 8 | 128;
                uuidArray[index++] = clockSeq & 255;

                for (let i = 0; i < 6; ++i) {
                    uuidArray[index + i] = node[i];
                }
                return byteArrayToHexString(uuidArray);
            }

            function getRandomValues() {
                let getRandom;
                const arr = new Uint8Array(16);
                if (!getRandom) {
                    getRandom = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
                    if (!getRandom)
                        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported")
                }
                return getRandom(arr)
            }
            let hexChars = [];
            for (let i = 0; i < 256; ++i) {
                hexChars.push((i + 256).toString(16).slice(1));
            }

            function byteArrayToHexString(byteArray, startIndex = 0) {
                return (
                    hexChars[byteArray[startIndex + 0]] +
                    hexChars[byteArray[startIndex + 1]] +
                    hexChars[byteArray[startIndex + 2]] +
                    hexChars[byteArray[startIndex + 3]] +
                    "-" +
                    hexChars[byteArray[startIndex + 4]] +
                    hexChars[byteArray[startIndex + 5]] +
                    "-" +
                    hexChars[byteArray[startIndex + 6]] +
                    hexChars[byteArray[startIndex + 7]] +
                    "-" +
                    hexChars[byteArray[startIndex + 8]] +
                    hexChars[byteArray[startIndex + 9]] +
                    "-" +
                    hexChars[byteArray[startIndex + 10]] +
                    hexChars[byteArray[startIndex + 11]] +
                    hexChars[byteArray[startIndex + 12]] +
                    hexChars[byteArray[startIndex + 13]] +
                    hexChars[byteArray[startIndex + 14]] +
                    hexChars[byteArray[startIndex + 15]]
                ).toLowerCase();
            }

            // canvas增加监听事件
            canvas.addEventListener('wheel', this.onWheel);
            canvas.addEventListener('dragover', this.onDragOver);
            canvas.addEventListener('dragleave', this.onDragExit);
            canvas.addEventListener('drop', this.onDrop);
            canvas.classList.add('costumer');

            // 获取按钮元素
            const deleteButton = document.getElementById('mesh_dispose');
            const download_json_file = document.getElementById('download');
            // 添加点击事件处理程序
            deleteButton.addEventListener('click', dispose_mesh);
            download_json_file.addEventListener('click', downloadCostume);

            engine.runRenderLoop(function () {
                scene.render();
            });

            window.addEventListener("resize", function () {
                engine.resize();
            });
        </script>
</body>

</html>